\section{Degenerate Strings}
% Brief introduction to degenerate strings \cite{fischer1974string, alzamel2018degenerate}
Given a finite non-empty alphabet $\Sigma$, a \emph{string} $X$ of length $N$ over $\Sigma$ is a sequence of $N$ symbols from $\Sigma$. We denote with $\Sigma^*$ the sets of all the strings in $\Sigma$, including the trivial one $\epsilon$ on length $0$. We can now introduce the concept of a \emph{degenerate string}, presented for the first time by Fischer and Paterson in 1974 \cite{fischer1974string} and has been used in various contexts since then \cite{alzamel2018degenerate}.

\begin{definition}[Degenerate String]\label{def:degenerate_string}
    A \emph{degenerate string} is a sequence $X = X_1 X_2 \ldots X_n$, where each $X_i$ is an element of $\Sigma^*$. We call $n$ the \emph{length} of $X$ and $N = \sum_{i=1}^{n} |X_i|$ the \emph{size} of $X$.
\end{definition}

\begin{definition}[Balanced Degenerate String]\label{def:balanced_degenerate_string}
    TODO
\end{definition}

\todo[inline]{TODO: Add an example of a degenerate string and add a few more lines to clarify the concept. Talk about their application in bioinformatics and why the literature is interested in them.}

\subsection{Subset-Rank and Subset-Select}
We have seen in depth the rank and select operations in \autoref{sec:bitvectors}. Where given a string $S$ from an alphabet $[1,\sigma]$, we showed how to answer the following queries efficiently:
\begin{itemize}
    \item $rank_S(c, i)$: the number of occurrences of the symbol $c$ in $S[1..i]$.
    \item $select_S(c, i)$: the position of the $i$-th occurrence of the symbol $c$ in $S$.
\end{itemize}
We can now extend these operations to degenerate strings. This problem was recently studied for the first time by Alanko, Biagi, Puglisi and Vuohtoniemi in \cite{SubsetWT}, where their goal was to support the following queries on degenerate strings:
\begin{itemize}
    \item $\texttt{subset-rank}_X(c, i)$: the number of sets in $X[1..i]=X_1 \dots X_i$ that contain the symbol $c$.
    \item $\texttt{subset-select}_X(c, i)$: the position of the $i$-th set that contains the symbol $c$
\end{itemize}
\begin{example}
    Let's consider the following degenerate string over the alphabet $\Sigma = \{A, B, C, D\}$:
    \[
        X = \{AAB\} \{CD\} \{\} \{A\} \{BCD\} \{\} \{C\} \{AB\} \{\} \{D\}
    \]
    Then for example we would have
    \begin{equation*}
        \texttt{subset-rank}_X(C, 6) = 2 \qquad \texttt{subset-select}_X(A, 2) = 3
    \end{equation*}
    since the symbol $C$ appears in order in the sets $\{CD\}$ and $\{BCD\}$ and the second set containing the symbol $A$ is $\{A\}$ ad index $3$.
\end{example}
% The interest in performing this types of queries comes from different problems that aries in pangenomics. In our case, the motivation that lead the authors of \cite{SubsetWT} to study this problem was to support fast membership queries on de Bruijn graphs. In particular in \cite{alanko2023small} the same authors defined the \emph{Spectral Burrows-Wheeler Transform} (\texttt{SBWT}): a particular sequence of subsets of the alphabet of the string that encodes $k$-spectrum of the string. With the \texttt{SBWT} they show how to represent the de Bruijn graph of all length-$k$ substrings of a string $S$ in a way that allows to answer membership queries by performing $2k$ \texttt{subset-rank} queries on the \texttt{SBWT} of $S$. In their experimentation, their approach that, compared to the state-of-the-art, its two order of magnitude faster if the space occupancy remains the same and one order of magnitude faster with improved space occupancy.
\noindent This type of queries are crucial for solving various problems encountered in pangenomics, the study of entire genomes across a species. In the context of de Bruijn graphs, which can be used to represent relationships between overlapping substrings in biological sequences, researchers in \cite{SubsetWT} aimed to enable efficient membership queries. \vspace{0.4cm}

\noindent Building upon this work, in \cite{alanko2023small} they introduced the \emph{Spectral Burrows-Wheeler Transform} (SBWT). This transform represents a string's $k$ spectrum (the collection of all $k$-length substrings) as a sequence of alphabet subsets, i.e a degenerate string. The authors demonstrated that the SBWT allows for efficient de Bruijn graph representation of all $k$-length substrings in a string $S$. Membership queries within this graph can be answered using just $2k$ \texttt{subset-rank} queries on $S$'s SBWT. \vspace{0.4cm}

\noindent Their experiments revealed significant performance improvements compared to previously \todo{Not anymore since in \cite{bille2023rank} they improved everything} existing methods. Their approach achieves two orders of magnitude faster query times while maintaining the same space usage. Additionally, with improved space efficiency, it offers a one order of magnitude speedup. \vspace{0.4cm}

\todo[inline]{There is the big problem that in \cite{bille2023rank} they revisit the rank-select problem on degenerate strings, introducing a new, natural parameter and reanalyzing existing reductions to rank-select on regular strings. Plugging in standard data structures, the time bounds for queries are improved exponentially while essentially matching, or improving, the space bounds. Furthermore, they provide a lower bound on space that shows that the reductions lead to succinct data structures in a wide range of cases. Their most compact structure matches the space of the most compact structure of Alanko et al. \cite{SubsetWT} while answering queries twice as fast. They also provide an implementation using modern vector processing features; it uses less than one percent more space than the most compact structure of Alanko et al. \cite{SubsetWT} while supporting queries four to seven times faster, and has competitive query time with all the remaining structures.}

\vspace{0.4cm}
\noindent There is of course a naive and straightforward way to support these queries in $O(1)$. Given a degenerate string $X$ of length $n$ over an alphabet $\Sigma=[1,\sigma]$, for each $c \in \Sigma$ store a bitmap $B_c$ of length $n$ where the $i$-th bit is set to $1$ if and only if $c$ is in $X_i$. This way we can answer the queries in $O(1)$ time. In fact,
\begin{equation*}
    \texttt{subset-rank}_X(c, i) = rank_{B_c}(1, i)
\end{equation*}
However, this approach requires $O(\sigma n)$ bits of space, which is not efficient if the alphabet is large or the degenerate string is long.
