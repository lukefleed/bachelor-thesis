\section{Subset Wavelet Trees} \label{sec:subset_wavelet_trees}
In order to support the subset-rank and subset-select queries on degenerate strings, Alanko et al. \cite{SubsetWT} introduced the \emph{Subset Wavelet Tree} (SWT). This data structure is built on top of the Wavelet Tree (WT) \cite{GrossiWT2003} (already covered in \autoref{sec:wavelet_trees}) and extends it to handle degenerate strings. In this section, we will first see how the SWT is constructed and then how it can be used to answer subset-rank and subset-select queries efficiently.

\subsection{Structure} \label{sec:swt_structure}

Imagine we have an alphabet with $\sigma = 2^n$ symbols, where n is a natural number. We can recursively construct a tree with $\sigma$ levels to represent all possible subsets of this alphabet. Each node in the tree corresponds to a unique subset. The root node represents the entire alphabet. Each child node of a node $v$ represents a subset, $A_v$, derived from its parent's alphabet. Let's delve deeper into this recursive process. For each node (except the root), we define its child nodes as follows: the left child represents the first half of the parent's alphabet, while the right child represents the second half. \vspace{0.4cm}

\noindent We also introduce $Q_v$, a subsequence containing all subsets that include at least one element from $A_v$. Notably, when $A_v$ represents the entire alphabet, $Q_v$ also includes the empty set. In addition to representing subsets, each node $v$ in our tree holds two bit vectors, $L_v$ and $R_v$, with a length equal to the size of the corresponding subsequence $Q_v$.
\begin{itemize}
    \item $L_v[i] = 1$: This indicates that the $i$-th subset in $Qv$ contains at least one character from the \emph{first half} of the alphabet associated with node $v$ ($Av$).
    \item $R_v[i] = 1$: This indicates that the $i$-th subset in $Q_v$ contains at least one character from the \emph{second half} of the alphabet associated with node $v$ ($A_v$).
\end{itemize}
We can leverage these bit vectors $L_v$ and $R_v$ to create a single string using the alphabet \{0, 1, 2, 3\}. The $i$-th character in this string is formed by a simple calculation:
\begin{equation}
    S_v[i] = 2 \cdot R_v[i] + L_v[i]
\end{equation}
This formula essentially packs the information from both bit vectors into a single digit. A value of $0$ indicates the subset doesn't contain elements from either half, $1$ signifies the first half only, $2$ signifies the second half only, and $3$ represents elements from both halves. \vspace{0.4cm}

\subsection{Subset-Rank Queries} \label{sec:subset_rank_queries}

\noindent The bit vectors $L_v$ and $R_v$ enable efficient rank queries. To find the rank of a character $c$ at position $i$ in the original alphabet, we perform the following steps:
\begin{enumerate}
    \item \textbf{Traverse the Tree}: We navigate from the root node down to the leaf node where the associated alphabet $A_v$ is the single-element set containing only character $c$.
    \item \textbf{Prefix Length Calculation}: During this traversal, for each visited node $v$, we calculate the length of the prefix within the current subsequence $Qv$. This prefix encompasses all subsets in the original data $(X_1,\dots, X_i)$ that include at least one character from $A_v$.
    \item \textbf{Rank Queries on Bit Vectors}: Similar to traditional wavelet tree queries, we leverage rank queries on the $L_v$ and $R_v$ bit vectors to determine this prefix length.
\end{enumerate}
Algorithm \ref{alg:subset-rank} offers pseudocode for this approach.


\subsection{Subset-Select Queries} \label{sec:subset_select_queries}

To answer subset-select queries, we follow a similar process to subset-rank queries.

\begin{enumerate}
    \item \textbf{Traversal from Leaf to Root:} We begin at the leaf node where the associated alphabet $A_v$ is the single-element set containing only character $c$. We then traverse back towards the root node.
    \item \textbf{Updating Position} ($i$): As we move through each node $v$ during traversal, we adjust the position $i$.
    \item \textbf{Prefix Length with $c$ Characters}: We calculate the length of the prefix within the current subsequence $Qv$. This prefix encompasses all subsets in the original data $(X_1,\dots, X_i)$ that collectively contain exactly $i$ occurrences of character $c$.
    \item \textbf{Select Queries on Bit Vectors}: Similar to operations in wavelet trees, we use select queries on the $L_v$ and $R_v$ bit vectors to determine this prefix length.
\end{enumerate}

\noindent Algorithm \ref{alg:subset-access} provides pseudocode for this approach. This method leverages the bit vectors to efficiently locate specific character occurrences without iterating through the entire dataset.

\begin{algorithm}[h]
    \caption{Subset-Rank Query}
    \label{alg:subset-rank}
    \begin{algorithmic}[1]
        \Require $c$: character from $[1, \sigma]$, $i$: index
        \Ensure The number of subsets $X_j$ such that $j \leq i$ and $c \in X_j$
    \end{algorithmic}
    \begin{algorithmic}
        \Function{Subset-Rank}{$c, i$}
        \State $v \gets \text{root}$
        \State $[l, r] \gets [0, \sigma]$ \Comment{\small{Range of alphabet indices}}
        \While{$l \neq r$}
        \If{$c \leq \frac{l+r}{2}$}
        \State $r \gets \left\lfloor \frac{l+r}{2} \right\rfloor$
        \State $i \gets rank_1(L_v, i)$
        \State $v \gets \text{left child of } v$
        \Else
        \State $l \gets \left\lceil \frac{l+r}{2} \right\rceil$
        \State $i \gets rank_1(R_v, i)$
        \State $v \gets \text{right child of } v$
        \EndIf
        \EndWhile
        \State \Return $i$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
    \caption{Subset-Select Query}
    \label{alg:subset-access}
    \begin{algorithmic}[1]
        \Require $c$: character from $[1, \sigma]$, $i$: index
        \Ensure The position of the $j$-th subset such that the $i$-th $c \in X_j$
    \end{algorithmic}
    \begin{algorithmic}
        \Function{Subset-Select}{$c, i$}
        \State $v \gets \text{leaf node with alphabet } A_v = \{c\}$
        \While{$v \neq \text{root}$} \Comment{\small{Traverse from leaf to root}}
        \State $u \gets \text{parent of } v$
        \If{$v = \text{left child of } u$}
        \State $i \gets select_1(L_v, i)$
        \Else
        \State $i \gets select_1(R_v, i)$
        \EndIf
        \State $v \gets u$
        \EndWhile
        \State \Return $i$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsection*{Space Complexity}
The subset wavelet answer subset rank and select queries in logarithmic time $(O(\log \sigma))$, since at each level (there are $\log \sigma$ levels) we perform constant time operations. However, the actual number of bits used vary based on the data we are working with. For a general set sequence, it's typically $2n(\sigma - 1) + o(n\sigma)$ bits. \vspace{0.4cm}

\noindent Visualizing the tree as a complete binary tree with $\sigma$ leaves (not explicitly stored) helps. If the sets are full, each internal node stores $2n$ bits\footnote{Since each set goes both to the left and to the right child at each level}, leading to a total space complexity of $(\sigma - 1)2n$ due to the number of internal nodes and their size. However, for balanced degenerate strings \ref{def:balanced_degenerate_string} (where most sets have one element), space usage improves. Since each set element corresponds to at most one symbol per level, the total sequence length is bounded by set sizes. This translates to a space complexity of $2n log \sigma$ bits across all $log \sigma$ tree levels. \vspace{0.4cm}

\noindent We can sum this up in the following theorem

\begin{theorem}[Space Complexity of Subset Wavelet Trees] \label{thm:swt_space}
    The subset wavelet tree of a balanced degenerate string takes $2n \log \sigma + o(n \log \sigma)$ bits of space and supports subset-rank and subset-select queries in $O(\log \sigma)$ time.
\end{theorem}

\subsection*{Rank for Base-$3$ and Base-$4$ Alphabets}

The subset wavelet tree (SWT) relies on efficiently answering regular rank queries on small alphabet sequences stored within its nodes. At the root node, the sequence uses a base-4 alphabet ($\Sigma = \{0, 1, 2, 3\}$), while all other nodes use a base-3 alphabet ($\Sigma = \{0, 1, 2\}$). \vspace{0.4cm}

\noindent However, the SWT requires a more specific operation than a standard rank query. It needs the sum of two rank queries: $rank(i, \Sigma - 1)$ and either $rank(i, \Sigma[0])$ or $rank(i, \Sigma[1])$. We call these combined operations \emph{rank-pair queries}. Here's how we can express rank-pair queries for base-4

\begin{align}
    rankpair(i,1) & = rank(i,1) + rank(i,3) \\
    rankpair(i,2) & = rank(i,2) + rank(i,3)
\end{align}

\noindent For base-3 alphabets, we can express rank-pair queries as follows:

\begin{align}
    rankpair(i,0) & = rank(i,0) + rank(i,2) \\
    rankpair(i,1) & = rank(i,1) + rank(i,2)
\end{align}

\noindent In the following section we will see different methods that Alanko et al. \cite{SubsetWT} proposed to answer rank and rank-pair queries on base-3 and base-4 alphabets. They developed these structures with the a clear and very specific goal in mind: answer efficiently membership queries on Spectral Burrows Wheeler Transform (SBWT) sequences. Moreover, they focused on 3 particular genomics dataset and exploited their specific proprieties to develop the most efficient data structures for their needs. This datasets are commonly used for $k$-mer indexing in bioinformatics and are the following:

\begin{enumerate} \label{datasets}
    \item \textbf{E. coli Pangenome:} This dataset consists of 3,682 E. coli genomes downloaded in 2020. It represents a subset of assemblies from NCBI's GenBank database\footnote{\url{ftp://ftp.ncbi.nlm.nih.gov/genomes/genbank/bacteria/assembly\_summary.txt}} filtered for "Escherichia coli" and downloaded before March 22nd, 2016. The complete dataset is available at\footnote{\url{zenodo.org/record/6577997}}.
    \item \textbf{Human Gut Illumina Reads:} This dataset contains 17,336,887 short DNA sequences (reads) of length 502 base pairs obtained from a study on human gut microbiota\footnote{SRA identifier ERR5035349} investigating irritable bowel syndrome and bile acid malabsorption \cite{jeffery2020differences}.
    \item \textbf{SARS-CoV-2 Genomes:} This dataset comprises 1,234,695 complete genomes of the SARS-CoV-2 virus, downloaded from NCBI datasets.
\end{enumerate}

\noindent The authors shows that when the Spectral Burrows Wheeler Transform (SBWT) is built on these datasets, the resulting degenerate strings present a very skewed distribution of the alphabet symbols, with the vast majority of the sets containing only one element.
