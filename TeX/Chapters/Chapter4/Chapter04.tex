\chapter{Succinct Representations of Weighted DAGs for Path Queries}
\label{chap:succinct_dags}

The preceding chapters have established a foundation in data compression (\autoref{ch:Chapter2}) and succinct data structures, particularly focusing on Rank and Select operations over sequences (\autoref{ch:Chapter3}). These tools are fundamental for achieving space-efficient representations while maintaining fast query capabilities, proving invaluable in areas like text indexing and computational genomics.

This chapter ventures into generalizing these concepts to node-weighted directed acyclic graphs (DAGs). We address the challenge of representing a DAG $G=(V, E, w)$, where each vertex $v \in V$ carries a non-negative integer weight $w(v)$, in a compressed format that efficiently supports queries related to cumulative path weights. Such weighted DAGs model various phenomena, from evolutionary pathways in biology, where weights might represent mutations or time, to task dependencies in project management, where weights signify durations or costs.

Our primary focus is on generalizing the Rank query to this graph setting; the Select query, while definable, will not be treated further in this work. For a given vertex $N$, the Rank query aims to describe the set of possible cumulative weights achievable on paths originating from a designated source vertex $s$ and terminating at $N$.

The combinatorial complexity of paths in a DAG—potentially exponential in the number of vertices—renders naive approaches based on explicit path enumeration or storage infeasible for large graphs. This motivates the development of a \emph{succinct} data structure. We introduce a novel representation strategy that partitions the vertices into two categories: \emph{explicit} vertices, for which path weight information is stored directly, and \emph{implicit} vertices, whose information is derived indirectly through references to other vertices via a carefully defined \emph{successor} relationship.

\section{Mathematical Framework}
\label{sec:dag_formal_defs}

\subsection*{Weighted Directed Acyclic Graphs}
\label{subsec:dag_def}

We begin with the formal definition of the object of study.

\begin{definition}[Weighted DAG]
    \label{def:weighted_dag}
    A node-weighted Directed Acyclic Graph (weighted DAG) is a triple $G = (V, E, w)$, where:
    \begin{itemize}
        \item $V$ is a finite set of vertices, typically identified with $\{0, 1, \dots, n-1\}$ where $n = |V|$.
        \item $E \subseteq V \times V$ is a set of directed edges such that the graph $(V, E)$ contains no directed cycles.
        \item $w: V \to \mathbb{N}_0$ is a weight function assigning a non-negative integer $w(v)$ to each vertex $v \in V$.
    \end{itemize}
    We denote the set of direct predecessors of $v$ as $Pred(v) = \{u \in V \mid (u, v) \in E\}$ and direct successors as $Succ(v) = \{u \in V \mid (v, u) \in E\}$. A vertex $v$ with $Succ(v) = \emptyset$ is called a \emph{sink} vertex.
\end{definition}

\begin{assumption}[Unique Source]
    \label{ass:unique_source}
    Without loss of generality, we assume $G$ possesses a unique source vertex $s \in V$ with $Pred(s) = \emptyset$. If multiple sources exist, a virtual source $s'$ with $w(s')=0$ can be added, with edges $(s', v)$ directed to all original sources $v$. We assume $s=0$ and $w(s)=0$.
\end{assumption}

\begin{definition}[Paths and Path Weights]
    \label{def:paths_weights}
    A path $P$ from vertex $u$ to vertex $v$ in $G$ is a sequence $P = (v_0, v_1, \dots, v_k)$ such that $v_0 = u$, $v_k = v$, and $(v_{j-1}, v_j) \in E$ for all $1 \le j \le k$. Let $Path(s, v)$ denote the set of all paths from the unique source $s$ to $v$. The cumulative weight relevant for our Rank query, denoted $W'(P)$, for a path $P=(v_0=s, \dots, v_k=v)$ is defined as the sum of weights excluding the source:
    \[ W'(P) = \sum_{j=1}^{k} w(v_j). \]
    If $k=0$ (i.e., $P=(s)$), then $W'(P)=0$.
\end{definition}

\subsection{Path Weight Aggregation}
\label{subsec:o_set_def}

To represent the set of all possible cumulative path weights ending at a vertex, we introduce the $\mathcal{O}$-set.

\begin{definition}[$\mathcal{O}$-Set]
    \label{def:o_set}
    For each vertex $v \in V$ in a weighted DAG $G=(V, E, w)$ with source $s$, the \emph{$\mathcal{O}$-set}, denoted $\mathcal{O}_v \subseteq \mathbb{N}_0$, is defined recursively. Assuming a topological ordering of $V$:
    \begin{itemize}
        \item For the source vertex $v = s$:
              \[ \mathcal{O}_s = \{0\}. \]
        \item For any other vertex $v \neq s$:
              \[ \mathcal{O}_v = \bigcup_{u \in Pred(v)} \{ y + w(v) \mid y \in \mathcal{O}_u \}. \]
    \end{itemize}
    The definition implies that $\mathcal{O}_v$ contains the unique values obtained through this process. We consider $\mathcal{O}_v$ as the sorted sequence of these unique values.
\end{definition}

\begin{proposition}[Semantic Interpretation of $\mathcal{O}$-Set]
    \label{prop:o_set_correctness}
    For any vertex $v \in V$, the set $\mathcal{O}_v$ contains exactly the set of cumulative weights $\{ W'(P) \mid P \in Path(s, v) \}$
\end{proposition}
\begin{proof}
    The proof proceeds by induction on the vertices $v \in V$, ordered according to a topological sort of $G$.
    \textit{Base Case:} For $v=s$, the only path is $P=(s)$, for which $W'(P)=0$. By Definition \ref{def:o_set}, $\mathcal{O}_s = \{0\}$. The proposition holds for $s$.
    \textit{Inductive Step:} Assume the proposition holds for all vertices $u$ preceding $v$ in the topological order, specifically for all $u \in Pred(v)$. We need to show $\mathcal{O}_v = \{ W'(P) \mid P \in Path(s, v) \}$.

    ($\subseteq$) Let $x \in \mathcal{O}_v$. By Definition \ref{def:o_set}, $x = y + w(v)$ for some $u \in Pred(v)$ and some $y \in \mathcal{O}_u$. By the inductive hypothesis, $y = W'(P')$ for some path $P' = (v_0=s, \dots, v_{k-1}=u) \in Path(s, u)$. Consider the path $P = (v_0, \dots, v_{k-1}, v_k=v)$ obtained by appending $v$ to $P'$. This is a valid path in $Path(s, v)$. Its weight is $W'(P) = \sum_{j=1}^{k} w(v_j) = (\sum_{j=1}^{k-1} w(v_j)) + w(v_k) = W'(P') + w(v) = y + w(v) = x$. Thus, $x$ is the weight of a path in $Path(s, v)$.

    ($\supseteq$) Let $P = (v_0=s, \dots, v_k=v)$ be an arbitrary path in $Path(s, v)$. Since $v \neq s$, $k \ge 1$. Let $u = v_{k-1}$ be the direct predecessor of $v$ on this path, so $u \in Pred(v)$. Let $P' = (v_0, \dots, v_{k-1})$ be the subpath ending at $u$. $P' \in Path(s, u)$. By the inductive hypothesis, its weight $W'(P') = \sum_{j=1}^{k-1} w(v_j)$ is in $\mathcal{O}_u$. Let $y = W'(P')$. By Definition \ref{def:o_set}, the value $y + w(v)$ must be an element of $\mathcal{O}_v$. But $y + w(v) = W'(P') + w(v_k) = \sum_{j=1}^{k} w(v_j) = W'(P)$. Thus, the weight $W'(P)$ is in $\mathcal{O}_v$.

    Since both inclusions hold, $\mathcal{O}_v = \{ W'(P) \mid P \in Path(s, v) \}$.
\end{proof}

We now establish a relationship between the size of the $\mathcal{O}$-set of a vertex and its successors, which is crucial to the correctness of the structure.

\begin{lemma}[$\mathcal{O}$-Set Cardinality Monotonicity along Edges]
    \label{lem:o_set_cardinality_monotonicity}
    Let $v \in V$ and let $u \in Succ(v)$ be any direct successor of $v$. Then, the cardinality of the $\mathcal{O}$-set of $v$ is less than or equal to the cardinality of the $\mathcal{O}$-set of $u$, i.e., $|\mathcal{O}_v| \le |\mathcal{O}_u|$.
\end{lemma}
\begin{proof}
    Consider the definition of $\mathcal{O}_u$:
    \[ \mathcal{O}_u = \bigcup_{p \in Pred(u)} \{ y + w(u) \mid y \in \mathcal{O}_p \}. \]
    Since $u \in Succ(v)$, it follows that $v \in Pred(u)$. Therefore, the term corresponding to the predecessor $v$ is included in the union:
    \[ \{ y + w(u) \mid y \in \mathcal{O}_v \} \subseteq \mathcal{O}_u. \]
    Let $S_v = \{ y + w(u) \mid y \in \mathcal{O}_v \}$. This set $S_v$ is formed by adding a constant $w(u)$ to each element of $\mathcal{O}_v$. Since $w(u) \ge 0$, the mapping $f: \mathcal{O}_v \to S_v$ defined by $f(y) = y + w(u)$ is injective. If $w(u)>0$, it's strictly injective. If $w(u)=0$, $S_v=\mathcal{O}_v$. In either case, the number of unique elements in $S_v$ is exactly equal to the number of unique elements in $\mathcal{O}_v$, so $|S_v| = |\mathcal{O}_v|$.
    Because $S_v$ is a subset of the elements considered for $\mathcal{O}_u$, and $\mathcal{O}_u$ contains only unique values resulting from the union, the number of unique values in $\mathcal{O}_u$ must be at least the number of unique values in $S_v$.
    Therefore, $|\mathcal{O}_u| \ge |S_v| = |\mathcal{O}_v|$.
\end{proof}

\begin{figure}[htbp] % htbp suggests placement preference: here, top, bottom, page
    \centering
    \begin{tikzpicture}[
        node distance=1.5cm and 1cm, % Restored original node distance
        base_node/.style={circle, draw=black, thick, minimum size=8mm, inner sep=0pt, font=\sffamily},
        root_node/.style={base_node, fill=red!60, text=black}, % Pastel red fill
        data_label/.style={font=\tiny\sffamily, text=black}, % Restored original data label style
        edge_style/.style={->, >={Stealth[length=2mm]}, thick, draw=black} % Restored original edge style
        ]

        % Nodes: {Weight} Label: {Corrected O-set} - Using original positioning where possible
        \node[root_node, label={[data_label, red, yshift=-0.3cm]below:(0)}] (0) at (0, 2) {0}; % O-set: {0}
        \node[base_node, label={[data_label]below:(1)}] (1) at (1.5, 0) {1}; % O-set: {1}
        \node[base_node, label={[data_label]above:(3)}] (3) at (1.5, 4) {3}; % O-set: {3}
        \node[base_node, label={[data_label]below:(7, 9)}] (6) at (3.5, 1.5) {6}; % O-set: {7, 9}
        \node[base_node, label={[data_label]below:(8)}] (7) at (4.5, 0) {7}; % O-set: {8}
        % Node 2: Using corrected O-set {5, 9, 11} with original label positioning style
        \node[base_node, label={[data_label, xshift=0.3cm]above:(5, 9, 11)}] (2) at (5.5, 4) {2};
        % Node 9: O-set {16, 17, 18}
        \node[base_node, label={[data_label]above:(16, 17, 18)}] (9) at (6.5, 2) {9};
        % Node 5: O-set {13, 21, 22, 23}
        \node[base_node, label={[data_label, xshift=0.3cm]below:(13, 21, 22, 23)}] (5) at (9, 0.5) {5}; % Adjusted X pos slightly vs original for layout
        % Node 10: O-set {15, 19, 21}
        \node[base_node, label={[data_label, xshift=0.3cm]above:(15, 19, 21)}] (10) at (8.5, 5) {10};
        % Node 8: Using corrected O-set {21, 23, ..., 31} with original label positioning style, requires multi-line
        \node[base_node, label={[data_label, align=left]right:(21, 23, 24, 25,\\ 26, 27, 29, 30, 31)}] (8) at (11, 3) {8};

        % Draw Edges (identical to original)
        \draw [edge_style] (0) -- (1);
        \draw [edge_style] (0) -- (3);
        \draw [edge_style] (1) -- (6);
        \draw [edge_style] (1) -- (7);
        \draw [edge_style] (3) -- (2);
        \draw [edge_style] (3) -- (6);
        \draw [edge_style] (6) -- (2);
        \draw [edge_style] (6) -- (9);
        \draw [edge_style] (7) -- (5);
        \draw [edge_style] (7) -- (9);
        \draw [edge_style] (2) -- (10);
        \draw [edge_style] (9) -- (5);
        \draw [edge_style] (9) -- (8);
        \draw [edge_style] (10) -- (8);
        \draw [edge_style] (5) -- (8);

    \end{tikzpicture}
    \caption{Example of a node-weighted DAG (restored original style). Each node $v$ contains its weight $w(v)$. The label associated with each node represents its calculated $\mathcal{O}$-set, $\mathcal{O}_v$.}
    \label{fig:dag_example} % Keeping the same label for consistency
\end{figure}

\begin{example}[$\mathcal{O}$-Set Calculation]
    \label{ex:o_set_calc}
    Consider the weighted DAG in \autoref{fig:dag_example}. Each node $v$ is labelled with its weight $w(v)$ inside the circle, and its corresponding $\mathcal{O}$-set, calculated according to Definition \ref{def:o_set}, is shown as a label (in blue). Let's trace the calculation for several nodes, assuming a topological order starting from the source node 0.

    \begin{itemize}
        \item \textbf{Node 0 (Source):} $w(0)=0$. By definition, $\mathcal{O}_0 = \{0\}$.
        \item \textbf{Node 1:} $Pred(1)=\{0\}$, $w(1)=1$.
              \[ \mathcal{O}_1 = \{ y + w(1) \mid y \in \mathcal{O}_0 \} = \{ 0 + 1 \} = \{1\}. \]
        \item \textbf{Node 3:} $Pred(3)=\{0\}$, $w(3)=3$.
              \[ \mathcal{O}_3 = \{ y + w(3) \mid y \in \mathcal{O}_0 \} = \{ 0 + 3 \} = \{3\}. \]
        \item \textbf{Node 6:} $Pred(6)=\{1, 3\}$, $w(6)=6$.
              \begin{align*}
                  \mathcal{O}_6 & = \left( \{ y + w(6) \mid y \in \mathcal{O}_1 \} \right) \cup \left( \{ z + w(6) \mid z \in \mathcal{O}_3 \} \right) \\
                                & = \{ 1 + 6 \} \cup \{ 3 + 6 \}                                                                                       \\
                                & = \{7\} \cup \{9\} = \{7, 9\}.
              \end{align*}
        \item \textbf{Node 7:} $Pred(7)=\{1\}$, $w(7)=7$.
              \[ \mathcal{O}_7 = \{ y + w(7) \mid y \in \mathcal{O}_1 \} = \{ 1 + 7 \} = \{8\}. \]
        \item \textbf{Node 2:} $Pred(2)=\{3, 6\}$, $w(2)=2$.
              \begin{align*}
                  \mathcal{O}_2 & = \left( \{ y + w(2) \mid y \in \mathcal{O}_3 \} \right) \cup \left( \{ z + w(2) \mid z \in \mathcal{O}_6 \} \right) \\
                                & = \{ 3 + 2 \} \cup \{ (7+2), (9+2) \}                                                                                \\
                                & = \{5\} \cup \{9, 11\} = \{5, 9, 11\}.
              \end{align*}

        \item \textbf{Node 9:} $Pred(9)=\{6, 7\}$, $w(9)=9$.
              \begin{align*}
                  \mathcal{O}_9 & = \left( \{ y + w(9) \mid y \in \mathcal{O}_6 \} \right) \cup \left( \{ z + w(9) \mid z \in \mathcal{O}_7 \} \right) \\
                                & = \{ (7+9), (9+9) \} \cup \{ 8 + 9 \}                                                                                \\
                                & = \{16, 18\} \cup \{17\} = \{16, 17, 18\}.
              \end{align*}

              % \item \textbf{Node 5:} $Pred(5)=\{7, 9\}$, $w(5)=5$.
              %       \begin{align*}
              %           \mathcal{O}_5 & = \left( \{ y + w(5) \mid y \in \mathcal{O}_7 \} \right) \cup \left( \{ z + w(5) \mid z \in \mathcal{O}_9 \} \right) \\
              %                         & = \{ 8 + 5 \} \cup \{ (16+5), (17+5), (18+5) \}                                                                      \\
              %                         & = \{13\} \cup \{21, 22, 23\} = \{13, 21, 22, 23\}.
              %       \end{align*}

              % \item \textbf{Node 10:} $Pred(10)=\{2\}$, $w(10)=10$. Using the correctly calculated $\mathcal{O}_2 = \{5, 9, 11\}$:
              %       \[ \mathcal{O}_{10} = \{ y + w(10) \mid y \in \mathcal{O}_2 \} = \{ (5+10), (9+10), (11+10) \} = \{15, 19, 21\}. \]

              % \item \textbf{Node 8:} $Pred(8)=\{5, 9, 10\}$, $w(8)=8$. Using the correct predecessor $\mathcal{O}$-sets:
              %       \begin{align*}
              %           \mathcal{O}_8 = & \left( \{ y + w(8) \mid y \in \mathcal{O}_5 \} \right) \cup \left( \{ z + w(8) \mid z \in \mathcal{O}_9 \} \right) \\
              %                           & \cup \left( \{ a + w(8) \mid a \in \mathcal{O}_{10} \} \right)                                                     \\
              %           =               & \{ (13+8), (21+8), (22+8), (23+8) \}                                                                               \\
              %                           & \cup \{ (16+8), (17+8), (18+8) \}                                                                                  \\
              %                           & \cup \{ (15+8), (19+8), (21+8) \}                                                                                  \\
              %           =               & \{ 21, 29, 30, 31 \} \cup \{ 24, 25, 26 \} \cup \{ 23, 27, 29 \}                                                   \\
              %           =               & \{ 21, 23, 24, 25, 26, 27, 29, 30, 31 \} \text{ (sorted unique values)}
              %       \end{align*}

    \end{itemize}
    This example illustrates the recursive computation of $\mathcal{O}$-sets. Each set captures the distinct cumulative weights achievable via paths from the source to that specific node. The process follows the topological ordering, propagating and transforming path weights from predecessors according to \ref{def:o_set}.
\end{example}

\subsection{The Rank Query}
\label{subsec:rank_dag_def}

We formally define the Rank query using the $\mathcal{O}$-set.

\begin{definition}[Rank Query on Weighted DAG]
    \label{def:rank_dag}
    Given a vertex $N \in V$ in a weighted DAG $G=(V, E, w)$, the Rank query, denoted $\mathrm{Rank}_G(N)$, returns a representation of a set of integers derived from $\mathcal{O}_N$. The target set is
    \[ S_N = \bigcup_{x \in \mathcal{O}_N} \{ z \in \mathbb{N}_0 \mid \max(0, x - w(N) + 1) \le z \le x \}. \]
    The query returns a minimal collection

    $$\mathcal{R}_N = \{[l_1, r_1], [l_2, r_2], \dots, [l_p, r_p]\}$$

    of disjoint, closed integer intervals such that
    $$\bigcup_{k=1}^{p} [l_k, r_k] = S_N$$

    and $r_k < l_{k+1}-1$ for all $k=1, \dots, p-1$.
\end{definition}

\begin{remark}
    The transformation from $\mathcal{O}_N$ to $S_N$ is specific to the application motivating this query. The definition formalizes the computation: generate the raw interval $[\max(0, x - w(N) + 1), x]$ for each $x \in \mathcal{O}_N$, then merge these intervals greedily after sorting them by start point. Intervals $[l_1, r_1]$ and $[l_2, r_2]$ (with $l_1 \le l_2$) are merged if $l_2 \le r_1 + 1$.
\end{remark}

\begin{example}[Rank Query Calculation with Disjoint Result]
    \label{ex:rank_calc_disjoint}
    Let's compute the Rank query for node $N=2$ in the DAG shown in \autoref{fig:dag_example}. From Example \ref{ex:o_set_calc}, we know:
    \begin{itemize}
        \item The weight of node 2 is $w(2) = 2$.
        \item The $\mathcal{O}$-set for node 2 is $\mathcal{O}_2 = \{ 5, 9, 11 \}$.
    \end{itemize}
    Following Definition \ref{def:rank_dag}, we first generate an interval $[\max(0, x - w(2) + 1), x]$ for each $x \in \mathcal{O}_2$:
    \begin{itemize}
        \item For $x=5$: $[\max(0, 5 - 2 + 1), 5] = [\max(0, 4), 5] = [4, 5]$
        \item For $x=9$: $[\max(0, 9 - 2 + 1), 9] = [\max(0, 8), 9] = [8, 9]$
        \item For $x=11$: $[\max(0, 11 - 2 + 1), 11] = [\max(0, 10), 11] = [10, 11]$
    \end{itemize}
    The initial set of intervals is:
    $$ \{ [4, 5], [8, 9], [10, 11] \} $$
    Next, we merge overlapping or adjacent intervals using the condition $l_2 \le r_1 + 1$. The final minimal collection of disjoint intervals is:
    $$ \mathrm{Rank}_G(2) = \{ [4, 5], [8, 11] \}. $$
    This set represents $S_2 = \{4, 5\} \cup \{8, 9, 10, 11\}$, correctly reflecting the disjoint nature arising from the gaps in the initial intervals generated from $\mathcal{O}_2$.
\end{example}


\section{The Succinct DAG Representation}
\label{sec:succinct_dag_representation}

Direct storage of all $\mathcal{O}$-sets is often infeasible. We outline a representation strategy aiming for succinctness, based on partitioning nodes and using indirect references.

\subsection*{Successor Selection Heuristic}
\label{subsec:successor_selection}

To enable the implicit representation, we define a successor function $\sigma$ for non-sink nodes.

\begin{definition}[Successor Function $\sigma$]
    \label{def:sigma_function}
    For each vertex $v \in V$ that is not a sink ($Succ(v) \neq \emptyset$), we select a designated successor $\sigma(v) \in Succ(v)$ using the following heuristic:
    \[ \sigma(v) \in \underset{u \in Succ(v)}{\operatorname{argmin}} \{ |\mathcal{O}_u| \}. \]
\end{definition}
Ties are broken consistently, for example, by choosing the successor with the smallest vertex ID among those minimizing the $\mathcal{O}$-set size. The function $\sigma$ is defined only for non-sink vertices.

\subsection*{Node Partitioning}
\label{subsec:node_partitioning}

The choice of $\sigma$ informs the partitioning of vertices into explicit and implicit sets.

\begin{definition}[Explicit and Implicit Vertices]
    \label{def:explicit_implicit}
    The set of vertices $V$ is partitioned into two disjoint sets:
    \begin{itemize}
        \item $V_E$: The set of \emph{explicit} vertices. These are the sink vertices of $G$:
              \[ V_E = \{ v \in V \mid Succ(v) = \emptyset \}. \]
        \item $V_I$: The set of \emph{implicit} vertices. These are all non-sink vertices:
              \[ V_I = V \setminus V_E = \{ v \in V \mid Succ(v) \neq \emptyset \}. \]
    \end{itemize}
    Explicit vertices serve as base cases in the query process, where path information ($\mathcal{O}$-sets) is stored directly. Implicit vertices rely on their designated successor $\sigma(v)$ to reconstruct their path information.
\end{definition}

\subsection{Structure Components}
\label{subsec:structure_components}

We represent the DAG $G=(V,E,w)$ using three components, typically realized as arrays indexed by vertex ID ($0$ to $n-1$), facilitating a Structure of Arrays (SoA) layout \footnote{The SoA organization allows separate processing and potential compression of weights, structural links, and path data, and can offer performance benefits due to data locality.}:

\begin{enumerate}
    \item \textbf{Weights $\mathcal{W}$:} Stores the weight $w(v)$ for each vertex $v$. Conceptually, $\mathcal{W}[v] = w(v)$.
    \item \textbf{Successor Information $\Sigma$:} Stores information guiding the traversal from implicit nodes. For certain nodes $v$, $\Sigma[v]$ will identify a designated successor vertex $\sigma(v)$. For others, it will mark them as explicit endpoints.
    \item \textbf{Associated Data $\mathcal{D}$:} Holds the core path information. For a vertex $v$, $\mathcal{D}[v]$ conceptually stores either its full $\mathcal{O}$-set (if $v$ is explicit) or an "offset sequence" $\mathcal{I}_v$ (if $v$ is implicit) that allows reconstructing $\mathcal{O}_v$ by referring to the data associated with $\sigma(v)$.
\end{enumerate}
% The SoA organization allows separate processing and potential compression of weights, structural links, and path data, and can offer performance benefits due to data locality.

Based on the partitioning defined in \ref{def:explicit_implicit}, we can describe the data stored in $\mathcal{D}$ for each vertex $v \in V$:

\begin{itemize}
    \item For $v \in V_E$: $\mathcal{D}[v]$ conceptually stores the sorted sequence $\mathcal{O}_v$. We denote this stored data as $\mathcal{D}_E(v)$.
    \item For $v \in V_I$: Let $u = \sigma(v)$. $\mathcal{D}[v]$ conceptually stores the \emph{offset sequence} $\mathcal{I}_v$. This sequence $\mathcal{I}_v = (j_0, j_1, \dots, j_{m-1})$ is a monotonically increasing sequence of $m = |\mathcal{O}_v|$ indices. The index $j_k$ indicates that the $k$-th element of $\mathcal{O}_v$, denoted $x_k$, can be derived from the $j_k$-th element of $\mathcal{O}_u$, denoted $y_{j_k}$, via the reconstruction rule $x_k = y_{j_k} - w(u)$. We denote this stored sequence as $\mathcal{D}_I(v)$.
\end{itemize}
The successor information $\Sigma[v]$ stores the ID of $\sigma(v)$ if $v \in V_I$, and a special marker if $v \in V_E$.

\begin{proposition}
    For any implicit node $v \in V_I$, let $u = \sigma(v)$ be its designated successor chosen according to Definition \ref{def:sigma_function}. Then $|\mathcal{O}_v| \le |\mathcal{O}_u|$.
\end{proposition}
\begin{proof}
    This follows directly from Lemma \ref{lem:o_set_cardinality_monotonicity}, as $\sigma(v)$ is one of the successors of $v$.
\end{proof}
This ensures that the length of the offset sequence $\mathcal{I}_v$ ($|\mathcal{O}_v|$) does not exceed the length of the sequence $\mathcal{O}_{\sigma(v)}$ it refers to.

In this way, using the heuristic introduced in \ref{subsec:successor_selection}, we aim to reduce the potential complexity associated with an implicit node $v$. By choosing a successor $\sigma(v)$ whose $\mathcal{O}$-set is as small as possible among the immediate options, we anticipate that the offset sequence $\mathcal{I}_v$, which references data related to $\mathcal{O}_{\sigma(v)}$, might involve smaller indices or exhibit properties more amenable to compression. This is a greedy strategy focused on local optimization.

\subsection*{Example of the Structure}
\label{subsec:structure_example}

To concretely illustrate the succinct representation, we revisit the DAG introduced in \autoref{fig:dag_example}. Its representation according to the principles outlined in \autoref{subsec:structure_components} is shown in \autoref{fig:succinct_dag_example}.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[
        node distance=1.5cm and 1cm, % Restored original node distance
        base_node/.style={circle, draw=black, thick, minimum size=8mm, inner sep=0pt, font=\sffamily},
        root_node/.style={base_node, fill=red!60, text=black}, % Pastel red fill
        implicit_node/.style={base_node}, % Standard style for implicit nodes
        explicit_node/.style={base_node, fill=green!40, text=black}, % Style for explicit nodes
        data_label/.style={font=\tiny\sffamily\bfseries, text=blue!70!black, inner sep=1pt}, % Adjusted data label style slightly
        edge_style/.style={->, >={Stealth[length=2mm]}, thick, draw=black!30}, % Normal edges faint
        successor_edge/.style={->, >={Stealth[length=2mm, width=1.5mm]}, very thick, draw=blue!65} % Highlighted successor edge
        ]

        % Nodes with weights and associated data (Offset I or O-set O)
        \node[root_node, label={[data_label, red!80!black, yshift=-0.3cm]below:{$\mathcal{I}_0=(0)$}}] (0) at (0, 2) {0};
        \node[implicit_node, label={[data_label, yshift=-0.3cm]below:{$\mathcal{I}_1=(0)$}}] (1) at (1.5, 0) {1};
        \node[implicit_node, label={[data_label, yshift=0.2cm]above:{$\mathcal{I}_3=(1)$}}] (3) at (1.5, 4) {3};
        \node[implicit_node, label={[data_label, xshift=-0.5cm, yshift=-0.3cm]below right:{$\mathcal{I}_6=(1, 2)$}}] (6) at (3.5, 1.5) {6};
        \node[implicit_node, label={[data_label, yshift=-0.3cm]below:{$\mathcal{I}_7=(1)$}}] (7) at (4.5, 0) {7};
        \node[implicit_node, label={[data_label, xshift=-0.8cm, yshift=0.2cm]above right:{$\mathcal{I}_2=(0, 1, 2)$}}] (2) at (5.5, 4) {2};
        \node[implicit_node, label={[data_label, yshift=0.2cm]above:{$\mathcal{I}_9=(1, 2, 3)$}}] (9) at (6.5, 2) {9};
        \node[explicit_node, label={[data_label, align=left, xshift=0.4cm]right:{$\mathcal{O}_8=\{21, 23, 24, 25,$ \\ $26, 27, 29, 30, 31\}$}}] (8) at (11.5, 3) {8};
        \node[implicit_node, label={[data_label, xshift=-0.5cm, yshift=-0.3cm]below right:{$\mathcal{I}_5=(0, 6, 7, 8)$}}] (5) at (9, 0.5) {5};
        \node[implicit_node, label={[data_label, xshift=-0.9cm, yshift=0.2cm]above right:{$\mathcal{I}_{10}=(1, 5, 6)$}}] (10) at (8.5, 5) {10};

        % Faint original edges
        \draw [edge_style] (0) -- (1); \draw [edge_style] (0) -- (3);
        \draw [edge_style] (1) -- (6); \draw [edge_style] (1) -- (7);
        \draw [edge_style] (3) -- (2); \draw [edge_style] (3) -- (6);
        \draw [edge_style] (6) -- (2); \draw [edge_style] (6) -- (9);
        \draw [edge_style] (7) -- (5); \draw [edge_style] (7) -- (9);
        \draw [edge_style] (2) -- (10);
        \draw [edge_style] (9) -- (5); \draw [edge_style] (9) -- (8);
        \draw [edge_style] (10) -- (8);
        \draw [edge_style] (5) -- (8);

        % Highlighted successor edges
        \draw [successor_edge] (0) -- (1); \draw [successor_edge] (1) -- (7);
        \draw [successor_edge] (3) -- (6); \draw [successor_edge] (6) -- (2);
        \draw [successor_edge] (7) -- (9); \draw [successor_edge] (2) -- (10);
        \draw [successor_edge] (9) -- (5); \draw [successor_edge] (5) -- (8);
        \draw [successor_edge] (10) -- (8);

    \end{tikzpicture}
    \caption{Illustration of the succinct DAG representation for the graph in \autoref{fig:dag_example}. Nodes are colored by type (root is red, implicit is standard black, explicit is green). Labels show the stored data: $\mathcal{O}_v$ for the explicit node (8) and the offset sequence $\mathcal{I}_v$ for implicit nodes. Highlighted blue edges indicate the chosen successor $\sigma(v)$ for each implicit node.}
    \label{fig:succinct_dag_example}
\end{figure}

The construction follows these steps. First, nodes are partitioned into explicit ($V_E$) and implicit ($V_I$) sets. Since node 8 is the only sink, $V_E=\{8\}$ (green node). All other nodes are implicit. Second, for each implicit node $v$, a successor $\sigma(v)$ is chosen from its direct successors $Succ(v)$ such that $|\mathcal{O}_{\sigma(v)}|$ is minimized, as per \ref{def:sigma_function}. These successor choices are indicated by the thick blue edges in the figure.

Third, the associated data $\mathcal{D}[v]$ is determined. For the explicit node $v=8$, the complete $\mathcal{O}$-set, $\mathcal{O}_8=\{21, 23, ..., 31\}$, is stored. For every implicit node $v$, the offset sequence $\mathcal{I}_v$ is stored instead. This sequence provides the indices needed to reconstruct $\mathcal{O}_v$ by referring to the $\mathcal{O}$-set of its designated successor, $\mathcal{O}_{\sigma(v)}$, using the rule $x_k = y_{j_k} - w(\sigma(v))$, where $x_k$ is the $k$-th element of $\mathcal{O}_v$ and $y_{j_k}$ is the element at index $j_k = \mathcal{I}_v[k]$ in $\mathcal{O}_{\sigma(v)}$. For example, node 3 has $\sigma(3)=6$. Its $\mathcal{O}$-set is $\mathcal{O}_3=\{3\}$. The successor's weight is $w(6)=6$ and its $\mathcal{O}$-set is $\mathcal{O}_6=\{7, 9\}$. To find $\mathcal{I}_3[0]$, we solve $3 = y_{j_0} - 6$, yielding $y_{j_0}=9$. Since 9 is at index 1 in $\mathcal{O}_6$, we store $\mathcal{I}_3=(1)$. The offset sequences for all other implicit nodes are computed similarly and shown in their labels in \autoref{fig:succinct_dag_example}.

To see how this structure is used in practice, consider the query process to retrieve the value $\mathcal{O}_7[0]$, i.e., the first element of $\mathcal{O}_7$. This corresponds to executing $\textsc{GetValue}(7, 0)$. The operation involves traversing the successor path starting from node 7 until the explicit node 8 is reached, as visualized in \autoref{fig:query_path_node7}.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[
        node distance=1.6cm and 1.1cm, % Base distance, actual positions set via coordinates
        base_node/.style={circle, draw=black, thick, minimum size=9mm, inner sep=0pt, font=\sffamily},
        implicit_node/.style={base_node},
        explicit_node/.style={base_node, fill=green!40, text=black},
        % Define specific label styles for reuse
        node_label_above/.style={font=\tiny\sffamily\bfseries, text=blue!70!black, inner sep=1pt, align=center, above, yshift=1mm},
        node_label_below/.style={font=\tiny\sffamily\bfseries, text=blue!70!black, inner sep=1pt, align=center, below, yshift=-2mm},
        node_label_inside/.style={font=\tiny\sffamily\bfseries, text=blue!70!black, inner sep=0pt, align=center}, % Changed color to match others
        % Edge labels
        step_label/.style={font=\sffamily\scriptsize, text=black, above, midway, sloped, yshift=1mm, inner sep=1pt}, % Added inner sep
        weight_label/.style={font=\sffamily\scriptsize, text=red!80!black, below, midway, sloped, yshift=-1mm, inner sep=1pt}, % Added inner sep
        annotation/.style={font=\sffamily\tiny, text=black, align=center}, % Consistent annotation style
        result_label/.style={font=\sffamily\scriptsize\bfseries, text=purple!80},
        successor_edge/.style={->, >={Stealth[length=2mm, width=1.5mm]}, very thick, draw=blue!65} % Pastel blue
        ]

        % Nodes involved in the query path with adjusted coordinates and labels to match the image
        \node[implicit_node, label={[node_label_inside]:{$\mathcal{I}_7=(1)$}}] (N7) at (0,0) {7};
        \node[implicit_node, label={[node_label_above]:{$\mathcal{I}_9=(1, 2, 3)$}}] (N9) at (3,1.5) {9};
        \node[implicit_node, label={[node_label_below, yshift=-8mm]:{$\mathcal{I}_5=(0, 6, 7, 8)$}}] (N5) at (5.5,-0.5) {5};
        \node[explicit_node, label={[node_label_above]:{$\mathcal{O}_8=\{21, 23, 24, 25,$ \\ $26, 27, 29, 30, 31\}$}}] (N8) at (8.5,1.5) {8};

        % % Annotations adjusted based on new node positions to match the image layout
        \node[annotation, anchor=south] at ([yshift=-0.5cm]N7.south) {index $k=0$, $sum=0$};
        \node[annotation, anchor=north] at ([yshift=0.8cm]N9.north) {index $k=1$, $sum=9$};
        \node[annotation, anchor=south] at ([yshift=-0.8cm]N5.south) {index $k=2$, $sum=14$};
        \node[annotation, anchor=east] at ([xshift=1.6cm, yshift=-0.7cm]N8.east) {index $k=7$, $sum=22$};

        % Successor Edges for the path with sloped labels
        \draw [successor_edge] (N7) -- node[step_label] {Use $\mathcal{I}_7[0]=\mathbf{1}$}
        node[weight_label] {$+ w(9)=9$} (N9);
        \draw [successor_edge] (N9) -- node[step_label] {Use $\mathcal{I}_9[1]=\mathbf{2}$}
        node[weight_label] {$+ w(5)=5$} (N5);
        \draw [successor_edge] (N5) -- node[step_label] {Use $\mathcal{I}_5[2]=\mathbf{7}$}
        node[weight_label] {$+ w(8)=8$} (N8);

        \node[annotation, below=1.1cm of N8, xshift=0.4cm] (Calc) {Retrieve $\mathcal{O}_8[7] = 30$. \\ Final Result = $30 - sum = 30 - 22 = \mathbf{8}$.}; % Slightly adjusted vertical position
        \node[result_label, below=0.1cm of Calc] {Result: $\mathcal{O}_7[0] = 8$};

    \end{tikzpicture}
    \caption{Visualisation of the query process for retrieving the element at index $k=0$ of $\mathcal{O}_7$. The path followed is $7 \to 9 \to 5 \to 8$. Offset indices $\mathcal{I}_7[0]=1$, $\mathcal{I}_9[1]=2$, and $\mathcal{I}_5[2]=7$ are used successively. Weights $w(9)=9$, $w(5)=5$, and $w(8)=8$ are accumulated ($sum = 9+5+8=22$). The base value $\mathcal{O}_8[7]=30$ is retrieved from the explicit node, and the final result is $30 - 22 = 8$.}
    \label{fig:query_path_node7} % Keep the same label if it replaces the previous figure
\end{figure}

The query trace depicted begins at node 7 with index $k=0$ and an accumulated sum of 0. It follows the successor $\sigma(7)=9$, uses the offset $\mathcal{I}_7[0]=1$ to determine the index for the next step, and adds $w(9)=9$ to the sum. The process continues to node $\sigma(9)=5$, using offset $\mathcal{I}_9[1]=2$ and adding $w(5)=5$ to the sum (now 14). Then it proceeds to node $\sigma(5)=8$, using offset $\mathcal{I}_5[2]=7$ and adding $w(8)=8$ (sum becomes 22). Node 8 is explicit, so the traversal stops. The value at the final index $k=7$ is retrieved from $\mathcal{O}_8$, which is $\mathcal{O}_8[7]=30$. Finally, the accumulated sum is subtracted: $30 - 22 = 8$. This correctly reconstructs the value $\mathcal{O}_7[0]$. This mechanism allows deriving path information for any implicit node by leveraging the explicitly stored data and the chain of offsets and weights.


% The next section would typically be the Query Algorithms section
\section{Query Algorithms}
\label{sec:query_algorithms}


Based on the succinct representation described in \autoref{sec:succinct_dag_representation}, we now detail the algorithms for reconstructing the $\mathcal{O}$-set of a vertex and computing the Rank query. The core idea is to leverage the successor information $\Sigma$ and the associated data $\mathcal{D}$ (either $\mathcal{O}$-sets for explicit nodes or offset sequences $\mathcal{I}$ for implicit nodes) to retrieve path weight information on demand.

\subsection{Reconstructing $\mathcal{O}$-Sets}
\label{subsec:reconstructing_o_sets}

The fundamental operation required for the Rank query is retrieving the $\mathcal{O}$-set for a given vertex $N$. Since $\mathcal{O}$-sets are stored directly only for explicit vertices ($V_E$), we need a method to reconstruct $\mathcal{O}_v$ for implicit vertices ($v \in V_I$). This is achieved by traversing the successor path $v, \sigma(v), \sigma(\sigma(v)), \dots$ until an explicit vertex is reached, accumulating weights and applying offset indices along the way.

We define a function, $\textsc{GetValue}(v, k)$, which computes the $k$-th smallest element of $\mathcal{O}_v$ (0-indexed).

\begin{algorithm}
    \caption{$\textsc{GetValue}(v, k)$: Compute the $k$-th element of $\mathcal{O}_v$}
    \label{alg:get_value}
    \small
    \begin{algorithmic}[1]
        \Require Vertex ID $v$, index $k \in \{0, \dots, |\mathcal{O}_v|-1\}$.
        \Ensure The $k$-th smallest value in $\mathcal{O}_v$.
        \State $current\_node \gets v$
        \State $current\_index \gets k$
        \State $weight\_sum \gets 0$
        \While{$current\_node \in V_I$} \Comment{While the node is implicit}
        \State $successor \gets \sigma(current\_node)$ \
        \State $weight\_sum \gets weight\_sum + \mathcal{W}[successor]$
        \State $\mathcal{I}_{current\_node} \gets \mathcal{D}_I(current\_node)$ \Comment{Get offset sequence for current node}
        \State $next\_index \gets \mathcal{I}_{current\_node}[current\_index]$
        \State $current\_node \gets successor$
        \State $current\_index \gets next\_index$
        \EndWhile
        \State $\mathcal{O}_{explicit} \gets \mathcal{D}_E(current\_node)$
        \State $base\_value \gets \mathcal{O}_{explicit}[current\_index]$
        \State \Return $base\_value - weight\_sum$
    \end{algorithmic}
\end{algorithm}

The correctness of $\textsc{GetValue}(v, k)$ stems from the definition of the offset sequence $\mathcal{I}_v$. By construction, the $k$-th element of $\mathcal{O}_v$, say $x_k$, satisfies $x_k = y_{j_k} - w(u)$, where $u = \sigma(v)$ and $y_{j_k}$ is the $j_k$-th element of $\mathcal{O}_u$, with $j_k = \mathcal{I}_v[k]$. The algorithm iteratively applies this relationship, following the successor chain $v \to u \to \dots \to e$ (where $e \in V_E$) and accumulating the weights $w(u), w(\sigma(u)), \dots, w(e)$. If the final index into $\mathcal{O}_e$ is $J$ and the retrieved value is $Y = \mathcal{O}_e[J]$, the algorithm correctly computes the target value as $Y - \sum_{z \in \{u, \sigma(u), \dots, e\}} w(z)$.

Using $\textsc{GetValue}$, we can reconstruct the entire $\mathcal{O}$-set for any vertex $v$. We need a way to determine the size of $\mathcal{O}_v$, denoted $|\mathcal{O}_v|$. This size information must be stored or efficiently computable for each vertex $v$. Let $\textsc{Length}(v)$ be a function returning $|\mathcal{O}_v|$.

\begin{algorithm}
    \caption{$\textsc{GetOSet}(v)$: Reconstruct the $\mathcal{O}$-set for vertex $v$}
    \label{alg:get_o_set}
    \small
    \begin{algorithmic}[1]
        \Require Vertex ID $v$.
        \Ensure The sorted sequence $\mathcal{O}_v$.
        \State $size \gets \textsc{Length}(v)$
        \State Initialize an empty list $O\_list$
        \For{$k$ from $0$ to $size - 1$}
        \State $value \gets \textsc{GetValue}(v, k)$
        \State Append $value$ to $O\_list$
        \EndFor
        \State \Return $O\_list$ \Comment{The list is inherently sorted}
    \end{algorithmic}
\end{algorithm}

\subsection{Computing the Rank Query}
\label{subsec:computing_rank}

With the ability to reconstruct $\mathcal{O}_N$ for any query vertex $N$, we can now implement the Rank query as defined in Definition \ref{def:rank_dag}. The process involves generating initial intervals based on $\mathcal{O}_N$ and then merging them into a minimal disjoint set. Algorithm \ref{alg:rank_dag} outlines this process.

\begin{algorithm}
    \caption{$\textsc{MergeIntervals}(Intervals)$: Merge sorted intervals}
    \label{alg:merge_intervals}
    \small
    \begin{algorithmic}[1]
        \Require A list $Intervals$ of intervals $[l, r]$, sorted by $l$.
        \Ensure A minimal list $MergedIntervals$ of disjoint intervals covering the same union.
        \State Initialize an empty list $MergedIntervals$
        \If{$Intervals$ is not empty}
        \State $current\_interval \gets Intervals[0]$
        \For{$i$ from $1$ to length$(Intervals) - 1$}
        \State $next\_interval \gets Intervals[i]$
        \If{$next\_interval.l \le current\_interval.r + 1$}
        \State $current\_interval.r \gets \max(current\_interval.r, next\_interval.r)$
        \Else
        \State Append $current\_interval$ to $MergedIntervals$
        \State $current\_interval \gets next\_interval$
        \EndIf
        \EndFor
        \State Append $current\_interval$ to $MergedIntervals$
        \EndIf
        \State \Return $MergedIntervals$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{$\mathrm{Rank}_G(N)$: Compute the Rank query for vertex $N$}
    \label{alg:rank_dag}
    \small % Reduce font size for the pseudocode
    \begin{algorithmic}[1]
        \Require Vertex ID $N$.
        \Ensure A minimal set of disjoint intervals $\mathcal{R}_N$ representing $S_N$.
        \State $\mathcal{O}_N \gets \textsc{GetOSet}(N)$
        \State $w_N \gets \mathcal{W}[N]$
        \State Initialize an empty list $Intervals$
        \For{each $x \in \mathcal{O}_N$}
        \State $l \gets \max(0, x - w_N + 1)$
        \State $r \gets x$
        \State Append the interval $[l, r]$ to $Intervals$
        \EndFor
        \State $MergedIntervals \gets \textsc{MergeIntervals}(Intervals)$
        \State \Return $MergedIntervals$
    \end{algorithmic}
\end{algorithm}

Algorithm \ref{alg:rank_dag} first reconstructs the necessary $\mathcal{O}$-set for the query vertex $N$. It then generates an initial set of potentially overlapping intervals based on Definition \ref{def:rank_dag}. Since these intervals are already sorted by construction, it calls Algorithm \ref{alg:merge_intervals} to perform a standard greedy interval merging process. This subroutine iterates through the sorted intervals, merging any interval that overlaps with or is immediately adjacent to the current merged interval, ultimately producing the minimal set of disjoint intervals $\mathcal{R}_N$ covering the target set $S_N$.

\subsubsection*{Example: Rank Query Computation \label{subsubsec:rank_query_example_node2}}

Let's trace the execution of Algorithm \ref{alg:rank_dag} to compute $\mathrm{Rank}_G(N)$ for the only node with weight $2$, in the representation already shown in \autoref{fig:dag_example} and \autoref{fig:succinct_dag_example}.

First, the algorithm requires the $\mathcal{O}$-set for node 2. It calls $\textsc{GetOSet}(2)$ (Algorithm \ref{alg:get_o_set}), which in turn relies on $\textsc{GetValue}(2, k)$ (Algorithm \ref{alg:get_value}) for $k=0, 1, \dots, |\mathcal{O}_2|-1$. $\textsc{GetValue}$ traverses the successor path determined by $\sigma$. For node 2, the successor path is $2 \to 10 \to 8$. Following this path, applying the stored offset indices $\mathcal{I}_2, \mathcal{I}_{10}$, accumulating weights $w(10)$ and $w(8)$, and finally retrieving the base value from the explicit node $\mathcal{O}_8$, yields the set $\mathcal{O}_2 = \{5, 9, 11\}$.

Next, the weight of the query node is retrieved: $w_N = w(2) = 2$.

The algorithm then proceeds to generate the initial set of intervals. Each element $x$ from $\mathcal{O}_2$ maps to an interval $[\max(0, x - w_2 + 1), x]$:
\begin{align*}
    x=5 \quad  & \longrightarrow \quad [\max(0, 5 - 2 + 1), 5] = [4, 5]     \\
    x=9 \quad  & \longrightarrow \quad [\max(0, 9 - 2 + 1), 9] = [8, 9]     \\
    x=11 \quad & \longrightarrow \quad [\max(0, 11 - 2 + 1), 11] = [10, 11]
\end{align*}
This yields the initial list $Intervals = \{ [4, 5], [8, 9], [10, 11] \}$.

Finally, $\textsc{MergeIntervals}$ (\ref{alg:merge_intervals}) is applied to this sorted list.
The process starts with $[4, 5]$. The next interval $[8, 9]$ does not overlap or touch $[4, 5]$ (since $8 > 5+1$). Thus, $[4, 5]$ is added to the result set.
The current interval becomes $[8, 9]$. The next interval is $[10, 11]$. Since $10 \le 9 + 1$, these intervals are merged: the new current interval becomes $[8, \max(9, 11)] = [8, 11]$.
As there are no more intervals, the last current interval $[8, 11]$ is added to the result set. The final result returned by $\mathrm{Rank}_G(2)$ is the minimal set of disjoint intervals $\mathcal{R}_2 = \{ [4, 5], [8, 11] \}$
