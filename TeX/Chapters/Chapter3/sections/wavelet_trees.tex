\clearpage
\section{Wavelet Trees}
% TODO: An introduction to wavelet trees, just one paragraph. (\cite{WTForALL,WTFromTheoryToPractice,TheMyriadVirtuesWT} give a good introduction to wavelet trees)

The wavelet tree was introduced in 2003 by Grossi, Gupta, and Vitter \cite{GrossiWT2003}, it serves as a space-efficient data structure for sequence representation and query handling. Its name reflects its similarity to wavelet packet decomposition, where the sequence's "high" and "low" symbol values are separated and recursively subdivided. \\

\noindent Interestingly, upon closer examination, one can recognize that the wavelet tree is a slight extension of an older (1988) data structure by Chazelle \cite{Chazelle1988}, commonly used in Computational Geometry. This structure represents points on a two-dimensional grid, undergoing a reshuffling process to sort them by one coordinate and then by the other. Kärkkäinen (1999) \cite{karkkainen1999repetition} was the first to apply this structure to text indexing, although the concept and usage differed from Grossi et al.'s proposal four years later. \\

\noindent Wavelet Trees can be seen in different ways: (i) as sequence representation, (ii) as a permutation of elements, and (iii) as grid point representation. Since 2003, these perspectives and their interconnections have proven valuable across diverse problem domains, extending beyond text indexing and computational geometry, where the structure originated \cite{WTForALL,WTFromTheoryToPractice,TheMyriadVirtuesWT}.

\subsection*{An introduction to the problem}
First introduce the following problem: let's consider a sequence $S[1,n]$ as a generalization of bitvectors whose elements $S[i]$ are drawn from an alphabet $\Sigma$\footnote{The size of the alphabet varies depending on the application. For example, in DNA sequences, the alphabet is $\Sigma = \{A,C,G,T\}$ (in \autoref{ch:Chapter4} we will focus more on this specific case), while in other case it could be of millions of characters, such as in natural language processing.}. The problem is to support the following queries:

\begin{itemize}
    \item \texttt{Access(i)}: return the $i$-th element of $S$.
    \item \texttt{Rank(c,i)}: return the number of occurrences of character $c$ in the prefix $S[1,i]$.
    \item \texttt{Select(c,i)}: return the position of the $i$-th occurrence of character $c$ in $S$.
\end{itemize}
However, dealing with sequences is much more complex than dealing with bitvectors (as we have seen in \autoref{sec:bitvectors})
\noindent TODO: further expand this concept: show an attemp to solve this problem with a naive approach, and see its shortcomings. The problem will be space occupancy, since if we use the solution for bitvectors, then the total space occupancy will be $n\sigma + o(n\sigma)$ bits, which is way too much. \cite{navarro2016compact} \\

\noindent From now on, let $S[1,n]$ = $s_1s_2\dots s_n$ be a sequence of length $n$ over an alphabet $\Sigma$ that for simplicity we write as $\Sigma = \{1,\dots,\sigma\}$. In this way, the string can be represented using $n \lceil \log \sigma \rceil = n \log \sigma + o(n)$ bits in plain form.

\subsection{Structure}

In the beginning of this section we showed that storing one bitvector per symbol is not space-efficient. The wavelet tree is a data structure that solves this problem by using a recursive hierarchical partitioning of the alphabet. Consider the subset $[a,b] \subset [1, \dots, \sigma]$, then a wavelet tree over $[a,b]$ is a balanced binary tree with $b-a+1$ leaves\footnote{if $a=b$ then the tree is just a leaf}. The root node $v_{root}$ is associated with the whole sequence $S[1,n]$, and stores a bitmap $B_{v_{root}}[1,n]$ defined as follows: $B_{v_{root}}[i] = 0$ if $S[i] \leq (a+b)/2$ and $B_{v_{root}}[i] = 1$ otherwise. The tree is then recursively built by associating the subsequence $S_0[1,n_0]$ of elements in $[a, \dots,\lfloor (a+b)/2 \rfloor ]$ to the left child of $v$, and the subsequence $S_1[1,n_1]$ of elements in $[\lfloor (a+b)/2 \rfloor +1,\dots, b]$ to the right child of $v$. This process is repeated until the leaves are reached. In this way the left child of the root node, is a wavelet tree for $S_0[1,n_0]$ and over the alphabet $[a,\dots, \lfloor (a+b)/2 \rfloor ]$, and the right child is a wavelet tree for $S_1[1,n_1]$ and over the alphabet $[\lfloor (a+b)/2 \rfloor +1,\dots, b]$. \cite{WTForALL}

\begin{example}
    TODO: Add an example of a wavelet tree for a sequence with small alphabet.
\end{example}

\begin{remark} \label{rem:space_occupancy_wavelet_tree}
    This wavelet tree has $\sigma$ leaves and $\sigma-1$ internal nodes, and the height of the tree is $ \lceil \log \sigma \rceil$. The space occupancy of each level it's exactly $n$ bits, while we have at most $n$ bits for the last level. The total number of bits stored by the wavelet tree in then upper bounded by $n \lceil \log \sigma \rceil$ bits. \cite{WTForALL}. This however is not sufficient, if we want to also store the topology of the tree, we need to add $O(\sigma \log n)$ bits.
\end{remark}

\subsubsection*{Tracking symbols}
We have seen how the wavelet tree serves as a representation for a string $S$, but moreover it is a succinct data structure for the string. Thus, it takes space asymptotically close to the plain representation of the string and allows us to access the $i$-th symbol of the string in $O(\log \sigma)$ time. In algorithm \ref{alg:access_wt} we show how extract the $i$-th symbol of the string $S$ using a wavelet tree $T$, this operation is called \texttt{Access}. \\

\begin{algorithm}[h!]
    \caption{Answering \texttt{Access} queries on a wavelet tree}\label{alg:access_wt}
    \begin{algorithmic}
        \Require Sequence $S$ (as a wavelet tree $T$), position $i$
        \Ensure The $i$-th symbol of $S$, i.e the output of \texttt{Access(S,i)}
        \State $[a,b] \gets [1,\sigma]$
        \While{$a \neq b$}
        \If{$access(v.B,i) =0$} \Comment{$i$-th bit of the bitmap of $v$}
            \State $i \gets rank_0(v.B,i)$
            \State $v \gets v.left$ \Comment{move to the left child of node $v$}
            \State $b \gets \lfloor (a+b)/2 \rfloor$
        \Else
            \State $i \gets rank_1(v.B,i)$
            \State $v \gets v.right$ \Comment{move to the right child of node $v$}
            \State $a \gets \lfloor (a+b)/2 \rfloor +1$
        \EndIf
        \EndWhile
        \State \Return $a$
    \end{algorithmic}
\end{algorithm}

\noindent In order to find $S[i]$, we first look at the bitmap associated with the root node of the wavelet tree, and depending on the value of the $i$-th bit of the bitmap, we move to the left or right child of the root node and continue recursively. However, the problem is to determine where our $i$ has been mapped to: if we move to the left child, then we need to find the $i$-th 0 in the bitmap of the left child, and if we move to the right child, then we need to find the $i$-th 1 in the bitmap of the right child. This is done by the $rank_0$ and $rank_1$ functions, respectively. We continue this process until we reach a leaf node, and then we return the value of the leaf node.

\begin{example}
    TODO and TBD: add a figure with the wavelet tree and the process of finding the $i$-th symbol of the string.
\end{example}

\noindent As we may want to retrive the $i$-th symbol of the string, we may also want to carry out the inverse operation, that is, given a symbol a position at a leaf node, we want to find the position of the symbol in the string. This operation is called \texttt{Select} and is shown in algorithm \ref{alg:select_wt}.\\

\noindent TODO: add the select algorithm and explain the process of finding the position of a symbol in the string. The references are Navarro's \cite{WTForALL,navarro2016compact} \\

\noindent TODO: Show how to generalize the rank and select operations to the wavelet tree. So with a query $rank_c(S,i)$ , instead of moving from the root toward the leaf corresponding to $S[i]$, we move toward the leaf of $c$. The idea is similar for select. \cite{navarro2016compact} 6.2.2 \\

\noindent TODO: Add some pratical consideration about using constant-time $rank$ and $select$ on the bitvectors. \cite{navarro2016compact} 6.2

\subsubsection*{TBD if to add: Reducing redundancy}
TODO: In \ref{rem:space_occupancy_wavelet_tree} we mentioned that storing the topology of the wavelet tree requires $O(\sigma \log n)$ bits. This may be critical for large alphabets, and in this section we will show that this term can be removed by slightly altering the balanced wavelet tree shape. \cite{MAKINEN2007332,MAKINEN2006703}.

\subsection{Construction}
TODO: Explain how to build a wavelet tree in $O(n \log n)$ time (and also talk about space occupancy), the procedure is well described in \cite{navarro2016compact} 6.2.3.

\begin{algorithm}
    \caption{Building a wavelet tree}\label{alg:build_wt}
    \begin{algorithmic}
        \Require Sequence $S[1,n]$ over alphabet $\Sigma = \{1,\dots,\sigma\}$
        \Ensure Wavelet tree $T$ for $S$
        \State TODO: add the algorithm to build the wavelet tree
    \end{algorithmic}
\end{algorithm}
