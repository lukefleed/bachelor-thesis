\chapter{Conclusion and Future Directions}
\label{chap:conclusion}

This thesis began by covering succinct data structures, data compression, and sequence queries. Building on that foundation, Chapter \ref{chap:succinct_dags} introduced our primary contribution: a space-efficient method for representing node-weighted Directed Acyclic Graphs (DAGs). This representation is specifically designed to support \Rank{} (\ref{def:rank_dag}) queries, which aggregate cumulative path weights ending at a particular vertex.

The core contribution presented in Chapter \ref{chap:succinct_dags} is a succinct representation strategy for weighted DAGs. Motivated initially by the reinterpretation of the degenerate string problem as a graph problem, we generalized the approach to arbitrary weighted DAGs. The key idea involves partitioning the vertices into two sets: explicit vertices ($V_E$), typically comprising the sink nodes, for which path weight information ($\mathcal{O}$-sets) is stored directly; and implicit vertices ($V_I$), for which this information is derived indirectly. This derivation relies on a carefully defined successor function, $\sigma$, which designates a specific successor for each implicit node, guiding a traversal path. Associated with each implicit node $v$, an offset sequence $\mathcal{I}_v$ stores the necessary indices to reconstruct its $\mathcal{O}$-set elements from the $\mathcal{O}$-set of its designated successor $\sigma(v)$. Query algorithms, notably \textsc{GetValue} and \textsc{GetOSet}, were presented, demonstrating how to reconstruct the path weight information by traversing these successor paths until an explicit node is reached.

Furthermore, we investigated compression strategies for the components of our structure,vertex weights $\mathcal{W}$, successor information $\Sigma$, and the associated data $\mathcal{D}$ (containing $\mathcal{O}$-sets or $\mathcal{I}$ sequences). Techniques such as variable-length integer coding and Run-Length Encoding, coupled with methods like Elias-Fano encoding for monotonic sequences, were discussed to minimize space occupancy. A significant finding highlighted in Section \ref{sec:below_entropy} is that the space usage of our proposed structure can fall below the established $0^{th}$-order entropy lower bound for lossless graph representation. This is possible because our structure is tailored specifically for the \Rank{} query and does not retain the full topological information (the complete edge set $E$) of the original DAG, thereby achieving high space efficiency for its designated task compared to both lossless graph encodings and methods based on precomputing query results.

While the developed succinct DAG representation offers substantial space savings, a potential performance consideration arises from the query evaluation process itself. The time required to compute a query for an implicit node $v$ depends directly on the length of the successor path that must be traversed from $v$ until an explicit node is encountered (as seen in Algorithm \ref{alg:get_value}). In large or deep DAGs, these paths could potentially become long, leading to variability and potentially slow query times in the worst case for certain nodes. This observation motivates a primary direction for future research: enhancing the query time predictability and efficiency by ensuring that all implicit nodes are reasonably close to an explicit node within the successor path structure.

To address this, instead of relying solely on the sink nodes as the base cases for path traversal, we propose a strategy based on ensuring a maximum traversal distance, denoted by a predefined integer $k$. The core idea is to augment the original set of explicit nodes $V_E$ (initially, the sinks) with a carefully selected subset of currently implicit nodes, resulting in a new, larger set of explicit nodes $V'_E \supseteq V_E$. This target set $V'_E$ must satisfy a specific property related to the successor function $\sigma$: every vertex $v$ that remains implicit (i.e., $v \in V \setminus V'_E$) must be able to reach some node $u \in V'_E$ by following the successor path defined by $\sigma$, using at most $k$ steps. More formally, let the successor path starting from $v$ be the sequence $v_0=v, v_1=\sigma(v_0), v_2=\sigma(v_1), \dots$. Then, for every $v \in V \setminus V'_E$, there must exist an index $j$, where $0 \le j \le k$, such that $v_j \in V'_E$.

The challenge then becomes selecting such a set $V'_E$ that is as small as possible, in order to minimize the additional space overhead associated with storing the $\mathcal{O}$-sets explicitly for these newly designated explicit nodes. This optimization problem is conceptually analogous to finding a minimum distance-$k$ dominating set in a graph. In the standard definition, a distance-$k$ dominating set $D$ is a subset of vertices such that every vertex not in $D$ is within a distance of $k$ (measured by the number of edges in a shortest path) from at least one vertex in $D$. Our formulation adapts this concept: the "distance" is measured specifically along the directed paths induced by the successor function $\sigma$, and the goal is to find a set $V'_E$ of minimum cardinality that "dominates" all other vertices within $k$ steps along these $\sigma$-paths. Finding a minimum distance-$k$ dominating set is known to be an NP-hard problem for general graphs. Given the added constraint of using only $\sigma$-paths, it is highly probable that determining an optimal set $V'_E$ of minimum size remains computationally intractable for large DAGs.

Consequently, a practical direction for future investigation involves the design and analysis of efficient heuristics. Such heuristics would aim to construct a set $V'_E$ satisfying the $k$-distance requirement along $\sigma$-paths, while keeping its size reasonably small, even if not guaranteeing absolute minimality. The choice of heuristic would need to balance the quality of the solution (size of $V'_E$) with the computational cost of finding it.

Once a suitable set $V'_E$ has been determined (whether optimally or via a heuristic), the successor selection function $\sigma$ needs to be redefined to leverage this structure. For an implicit node $v \in V \setminus V'_E$, the choice of its designated successor $\sigma(v)$ from the set $Succ(v)$ should prioritize reaching \emph{any} node within the target set $V'_E$ as quickly as possible along the subsequent $\sigma$-path. That is, $\sigma(v)$ should ideally be selected as the node $u \in Succ(v)$ which minimizes the length of the $\sigma$-path starting from $u$ to the nearest node in $V'_E$. Ties in path length could be resolved using secondary criteria, such as minimizing the $\mathcal{O}$-set cardinality $|\mathcal{O}_u|$ (as in the original heuristic) or simply selecting the successor with the minimum vertex identifier.

Implementing this refined strategy directly imposes an upper bound of $k$ on the number of iterations performed by the main loop in Algorithm \ref{alg:get_value}. This provides a worst-case guarantee on the time complexity of the path traversal component for any \Rank{} query, making the overall query performance significantly more predictable and uniform across all nodes, regardless of their position within the DAG. The main trade-off shifts to the selection of the parameter $k$: smaller values of $k$ yield faster worst-case query times but likely necessitate larger (and thus more space-consuming) sets $V'_E$, whereas larger values of $k$ may permit smaller sets $V'_E$ at the expense of a higher query time bound.
