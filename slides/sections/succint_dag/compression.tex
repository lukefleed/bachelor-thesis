% --- SLIDE 19: Compression Strategies - Overview ---
\begin{frame}{Compression Strategies}
    \framesubtitle{Reducing Memory Footprint}
    \begin{center}
        \begin{tabular}{l l}
            \toprule
            \textbf{Component}              & \textbf{Description}                             \\
            \midrule
            % Le prime due righe appaiono insieme al passo 1
            \uncover<1->{%
            $\mathcal{W}$ (Node weights)    & Array of positive integers.                      \\
            } % Appare dalla slide 1 in poi
            \uncover<1->{%
            $\Sigma$ (Successor IDs)        & Array of positive integers.                      \\
            } % Appare dalla slide 1 in poi
            % L'ultima riga e la linea inferiore appaiono al passo 3
            \uncover<3->{%
            $\mathcal{D}$ (Associated Data) & Array of arrays of increasing positive integers. \\
                \bottomrule
            } % Appare dalla slide 3 in poi
        \end{tabular}
    \end{center}
    \vspace{-1.5em}
    % Il blocco alert appare al passo 2, insieme ai primi due item
    \begin{alertblock}{Compression Options}<2-> % Appare dalla slide 2 in poi
        \begin{itemize}
            % I primi due item appaiono al passo 2
            \item<2-> Variable-Length Integer Coding $\longrightarrow$ we published a Rust library\footnote[1]{\url{https://crates.io/crates/compressed-intvec}} for this! % Appare dalla slide 2 in poi
            \item<2-> Wavelet Trees \emph{(for nodes with small weight range)} % Appare dalla slide 2 in poi
                % Gli ultimi due item appaiono al passo 4
            \item<4-> Elias-Fano Encoding \emph{(for monotonic sequences)} % Appare dalla slide 4 in poi
            \item<4-> Run-Length Encoding (RLE) \emph{(for clustered monotonic sequences)} % Appare dalla slide 4 in poi
        \end{itemize}
    \end{alertblock}
\end{frame}


% \begin{frame}{Compressing Weights ($\mathcal{W}$) and Successors ($\Sigma$)}
%     \framesubtitle{Handling General Integer Sequences}

%     \begin{itemize}
%         \item Both $\mathcal{W}$ (weights) and $\Sigma$ (successor IDs / markers) are arrays of non-negative integers.
%         \item No guaranteed order or distribution.
%     \end{itemize}


%     \begin{block}{Compression Options}
%         \begin{itemize}
%             \item \textbf{Variable-Length Integer Codes}: \alert{(Primary Approach)}
%                   \begin{itemize}
%                       \item Examples: Elias Gamma/Delta, Rice codes.
%                       \item Choice depends on the \emph{actual distribution} of values.
%                             %   \item Combine with sampling (\texttt{compressed-intvec}) for $O(1)$ expected random access. \alert{(Primary Approach)}
%                   \end{itemize}
%             \item \textbf{Wavelet Trees / Matrices}:
%                   \begin{itemize}
%                       \item If value range (max weight or $n$) is small (small alphabet $\alpha$).
%                       \item $O(\log \alpha)$ access time. Less feasible for large graphs.
%                   \end{itemize}
%         \end{itemize}
%     \end{block}
% \end{frame}

% \begin{frame}{Compressing Associated Data ($\mathcal{D}$)}
%     \framesubtitle{Exploiting Monotonicity}

%     Component $\mathcal{D}$ stores:
%     \begin{itemize}
%         \item $\mathcal{O}_v$ (O-Sets) for Explicit nodes ($v \in V_E$).
%         \item $\mathcal{I}_v$ (Offset Sequences) for Implicit nodes ($v \in V_I$).
%     \end{itemize}
%     \begin{alertblock}{Key Property}
%         Both $\mathcal{O}_v$ and $\mathcal{I}_v$ sequences are \textbf{strictly increasing (monotonic)!}
%     \end{alertblock}
%     \begin{block}{Suitable Compression Techniques}
%         \begin{itemize}
%             \item \textbf{Elias-Fano Encoding}:
%                   \begin{itemize}
%                       \item Excellent compression for monotonic sequences and $O(1)$ random access time
%                             %   \item Natively supports efficient random access ($O(1)$).
%                             %   \item Good general choice.
%                   \end{itemize}
%             \item \textbf{Run-Length Encoding (RLE)}:
%                   \begin{itemize}
%                       \item Potentially better if the sequence has long \emph{runs} of consecutive integers
%                             %   \item We'll look at this next.
%                   \end{itemize}
%         \end{itemize}
%     \end{block}

% \end{frame}

% \begin{frame}{Run-Length Encoding (RLE) for Monotonic Sequences}
%     \framesubtitle{Compressing Runs of Consecutive Integers}

%     Idea: Represent $Y = (y_0, y_1, \dots, y_{m-1})$ by its maximal runs.
%     \begin{itemize}
%         \item Example Run: $(10, 11, 12, 13)$ $\implies$ Start: 10, Length: 4
%     \end{itemize}


%     RLE generates two sequences:
%     \begin{itemize}
%         \item \textbf{$S = (s_1, \dots, s_p)$}: Sequence of \alert{Run Starts}.
%               \begin{itemize}
%                   \item Property: $S$ is strictly increasing $\implies$ Compress with \textbf{Elias-Fano}.
%               \end{itemize}
%         \item \textbf{$L = (l_1, \dots, l_p)$}: Sequence of positive \alert{Run Lengths}.
%               \begin{itemize}
%                   \item Property: General integers $\implies$ Compress with \textbf{Variable-Length Codes}
%               \end{itemize}
%     \end{itemize}

%     % Optional simple diagram: Y -> (S, L)
%     \begin{center}
%         \uncover<2->{
%             \begin{tikzpicture}[node distance=0.5cm]
%                 \node (Y) {$Y = (\dots, \alert{10, 11, 12, 13}, 15, \alert{20}, \dots)$};
%                 \node (SL) [below=of Y] {$S=(\dots, \alert{10}, 15, \alert{20}, \dots)\qquad L=(\dots, \alert{4}, 1, \alert{1}, \dots)$};
%                 \draw [->, thick, blue!60] (Y) -- (SL);
%             \end{tikzpicture}
%         }
%     \end{center}

% \end{frame}

% \begin{frame}{RLE Access \& Choice vs Elias-Fano}
%     \framesubtitle{Trade-offs}

%     \begin{block}{Random Access with RLE ($y_k$)}
%         To find the element at index $k$ in the original sequence ($y_k$):
%         \begin{enumerate}
%             \item Find the run $i^*$ containing index $k$: elements are covered by runs $1, \dots, i^*-1$.
%                   \begin{itemize}
%                       \item \emph{Slow way}: Sum run lengths $l_1 + l_2 + \dots$ on the fly ($O(p)$ time).
%                       \item \emph{Fast way}: Precompute prefix sums $P=(p_1, \dots, p_p)$ of $L$. Find $i^*$ via search on $P$
%                   \end{itemize}
%             \item Calculate $y_k = s_{i^*} + (\text{offset within run } i^*)$.
%                   \vspace{-0.5em}
%                   $$y_k = s_{i^*} + \left( k - (\text{elements before run } i^*) \right)$$
%         \end{enumerate}
%     \end{block}

%     % \vspace{1em} % Reduced space slightly

%     \begin{alertblock}{When to use RLE vs Elias-Fano?}
%         \begin{itemize}
%             \item Use \textbf{RLE} if \#Runs ($p$) $\ll$ \#Elements ($m$). (Good clustering).
%             \item Use \textbf{Elias-Fano} directly if sequence is sparse or has few runs ($p \approx m$).
%         \end{itemize}
%     \end{alertblock}

% \end{frame}
